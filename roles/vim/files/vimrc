"### Base ###
scriptencoding utf-8
filetype detect
syntax on

colorscheme delek

set number
set ruler
set nocompatible

" tmp files
set backup
set backupdir=~/.vim-tmp

set undofile
set undodir=~/.vim-tmp

set swapfile
set directory=~/.vim-tmp

" search
set incsearch
set hlsearch
set showmatch

" white characters
set list
set listchars=eol:$,tab:>\ ,extends:<

" indent
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set autoindent
set smartindent

" disable cusor key
nnoremap <Up> <NOP>
nnoremap <Down> <NOP>
nnoremap <Left> <NOP>
nnoremap <Right> <NOP>

inoremap <Up> <NOP>
inoremap <Down> <NOP>
inoremap <Left> <NOP>
inoremap <Right> <NOP>

" keep indent of blank line
nnoremap o oX<C-h>
nnoremap O OX<C-h>
inoremap <CR> <CR>X<C-h>

" Transition a command mode.
nnoremap ; :



"### NeoBundle ###
if has('vim_starting')
  set runtimepath+=~/.vim/bundle/neobundle.vim
  call neobundle#rc(expand('~/.vim/bundle/'))
endif

" Interactive command execution
NeoBundle 'Shougo/vimproc.vim', {
      \ 'build': {
      \   'windows': 'make -f make_mingw32.mak',
      \   'cygwin': 'make -f make_cygwin.mak',
      \   'mac': 'make -f make_mac.mak',
      \   'unix': 'make -f make_unix.mak',
      \ },
      \}

" Input completion
NeoBundle 'Shougo/neocomplete.vim'

" Shell
NeoBundle 'Shougo/vimshell.vim'

" Filer & Launcher
NeoBundle 'Shougo/unite.vim'

" Show outline
NeoBundle 'Shougo/unite-outline'

" Output the QuickFix content to the Unite buffer.
NeoBundle 'osyo-manga/unite-quickfix'

" Virtual Caps Lock
NeoBundle 'tpope/vim-capslock'

" Comment out
NeoBundle 'tyru/caw.vim'

" Show indent line
NeoBundle 'Yggdroot/indentLine'

" Highlight QuickFix
NeoBundle "jceb/vim-hier"

" YAML Syntax (with Ansible PlayBook highlighting)
NeoBundle 'chase/vim-ansible-yaml'

" CoffeeScript Syntax
NeoBundle 'kchmck/vim-coffee-script'

" TypeScript Syntax
NeoBundle 'leafgarland/typescript-vim'

" C++ Syntax
NeoBundleLazy 'vim-jp/cpp-vim'

" C++ Input completion (use Clang)
NeoBundleLazy 'Rip-Rip/clang_complete', {
      \ 'autoload': {'filetypes': 'cpp'}
      \}



"### NeoComplete.vim ###
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_ignore_case = 1
let g:neocomplete#enable_smart_case = 1

if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif

let g:neocomplete#keyword_patterns._ = '\h\w*'

inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"

" for clang_complete
if !exists('g:neocomplete#force_omni_input_patterns')
  let g:neocomplete#force_omni_input_patterns = {}
endif

let g:neocomplete#force_overwrite_completefunc = 1
let g:neocomplete#force_omni_input_patterns.c =
      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
let g:neocomplete#force_omni_input_patterns.cpp =
      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
let g:neocomplete#force_omni_input_patterns.objc =
      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
let g:neocomplete#force_omni_input_patterns.objcpp =
      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'



"### vimshell.vim ###
nnoremap <silent> ,s :<C-u>VimShell<CR>



"### Capslock.vim ###
imap <C-a> <C-O><Plug>CapsLockToggle



"### unite.vim ###
let g:unite_abbr_highlight = 'Normal'

" filer
function! g:unite_filer()
  if getcwd() == expand('~')
    Unite file
  else
    Unite file_rec
    call feedkeys('i')
  endif
endfunction

nnoremap <silent> f :<C-u>call g:unite_filer()<CR>

" grep
let g:unite_source_grep_default_opts = '-iRHn'

nnoremap ,g :<C-u>Unite -buffer-name=search-buffer grep:::
vnoremap <silent> ,g y:Unite -buffer-name=search-buffer grep:::<C-R>=escape(@", ':\\.*$^[]')<CR><CR>
nnoremap <silent> ,r  :<C-u>UniteResume search-buffer<CR>



"### unite-outline ###
nnoremap <silent> ,o :<C-u>Unite -vertical outline<CR>



"### unite-quickfix ###
nnoremap <silent> ,q :<C-u>Unite quickfix<CR>



"### Caw.vim ###
nmap \c <Plug>(caw:I:toggle)
vmap \c <Plug>(caw:I:toggle)

nmap \C <Plug>(caw:I:uncomment)
vmap \C <Plug>(caw:I:uncomment)



"### IndentLine ###
let g:indentLine_showFirstIndentLevel = 1



"### clang_complete ###
let g:clang_periodic_quickfix = 0
let g:clang_hl_errors = 0
let g:clang_complete_copen = 1

let g:clang_complete_auto = 0
let g:clang_auto_select = 0
let g:clang_use_library = 1

let g:clang_exec = $VIM_CLANG_PATH
let g:clang_library_path = $VIM_CLANG_LIB_PATH
let g:clang_user_options = '-std=gnu++1y -stdlib=libc++'



"### Zenkaku Space settings ###
function! s:show_zenkaku_space()
  highlight zenkaku_space cterm=underline ctermfg=lightblue guibg=darkgray
endfunction

if has('syntax')
  augroup vimrc-zenkaku_space
    autocmd!
    autocmd ColorScheme * call s:show_zenkaku_space()
    autocmd VimEnter,WinEnter,BufRead * let w:m1=matchadd('zenkaku_space', 'ã€€')
  augroup END
  call s:show_zenkaku_space()
endif



"### Build settings ###
function! s:build(...)
  if !empty(a:000)
    let $_build_command = 'zsh -i -l -c "'. join(a:000, ' ') .'"'
  endif
  
  if !empty($_build_command)
    setlocal makeprg=$_build_command
  endif
  
  make
endfunction

command! -nargs=* Build :call s:build(<f-args>)

nnoremap ,b :<C-u>Build<Space>



"### Path settings ###
function! s:add_path()
  let l:config_file = '.vim-path'
  let l:current_dir = expand('%:p:h')
  while 1
    let l:path = l:current_dir .'/'. l:config_file
    if filereadable(l:path)
      for $_line in readfile(l:path)
        let $_line = expand($_line)
        if $_line[0] != '/'
          let $_line = l:current_dir .'/'. $_line
        endif
        let $_line = fnamemodify($_line, ':p')[0:-2]
        setlocal path+=$_line
      endfor
      break
    endif
    if l:current_dir == '/'
      break
    endif
    let l:current_dir = fnamemodify(l:current_dir, ':h')
  endwhile
endfunction

augroup vimrc-path
  autocmd!
  autocmd BufReadPost * call s:add_path()
augroup END



"### FileType settings ###
" C++
function! s:cpp()
  setlocal path+=$VIM_CPP_INCLUDE
  setlocal tabstop=4
  setlocal shiftwidth=4
  setlocal softtabstop=4
  setlocal matchpairs+=<:>
  
  syntax match boost_pp /BOOST_PP_[A-z0-9_]*/
  highlight link boost_pp cppStatement
endfunction

function! s:cpp_stdlib()
  if empty(&filetype)
    set filetype=cpp
  elseif &filetype == 'cpp'
    syntax on
  endif
endfunction

augroup vimrc-cpp
  autocmd!
  let $_stdlib_files = join(map(split($VIM_CPP_STDLIB,','), 'v:val . "/*"'), ',')
  autocmd BufReadPost $_stdlib_files call s:cpp_stdlib()
  autocmd FileType cpp call s:cpp()
augroup END


" CoffeeScript
augroup vimrc-coffeescript
  autocmd!
  autocmd BufReadPost *.coffee.erb setlocal filetype=coffee
augroup END


" Makefile
function! s:makefile()
  setlocal noexpandtab
  setlocal tabstop=4
  setlocal shiftwidth=4
  setlocal softtabstop=4
endfunction

augroup vimrc-makefile
  autocmd!
  autocmd FileType make call s:makefile()
augroup END
